/*
  oclif command to update the balances stored in the wallet.json file.

  TODO:
  -Add BIP44 support
  -Batch requests 20-addresses at-a-time
*/

"use strict"

const AppUtils = require("../util")
const appUtils = new AppUtils()

const BB = require("bitbox-sdk")
const BITBOX = new BB({ restURL: "https://rest.bitcoin.com/v2/" })

// Used for debugging and error reporting.
const util = require("util")
util.inspect.defaultOptions = { depth: 2 }

const { Command, flags } = require("@oclif/command")

class UpdateBalances extends Command {
  constructor(argv, config) {
    super(argv, config)

    this.BITBOX = BITBOX
  }

  async run() {
    try {
      const { flags } = this.parse(UpdateBalances)

      this.validateFlags(flags)

      const name = flags.name

      // Open the wallet data file.
      const filename = `${__dirname}/../../wallets/${name}.json`
      let walletInfo = appUtils.openWallet(filename)
      walletInfo.name = name

      console.log(`Existing balance: ${walletInfo.balance} BCH`)

      // Determine if this is a testnet wallet or a mainnet wallet.
      if (walletInfo.network === "testnet")
        this.BITBOX = new BB({ restURL: "https://trest.bitcoin.com/v2/" })

      // Update the balances in the wallet.
      walletInfo = await this.updateBalances(filename, walletInfo)

      console.log(`Updated balance: ${walletInfo.balance} BCH`)
    } catch (err) {
      if (err.message) console.log(err.message)
      else console.log(`Error in UpdateBalances.run: `, err)
    }
  }

  // Validate the proper flags are passed in.
  validateFlags(flags) {
    // Exit if wallet not specified.
    const name = flags.name
    if (!name || name === "")
      throw new Error(`You must specify a wallet with the -n flag.`)

    return true
  }

  // Update the balances in the wallet.
  async updateBalances(filename, walletInfo) {
    console.log(`debug: walletInfo.nextAddress = ${walletInfo.nextAddress}`)

    // Query data on each address that has been generated by the wallet.
    //const addressData = await this.getAddressData(walletInfo)
    const addressData = await this.getAllAddressData(walletInfo)
    //console.log(`addressData: ${util.inspect(addressData)}`)

    // Update hasBalance array with non-zero balances.
    const hasBalance = this.generateHasBalance(addressData)

    // Sum all the balances in hasBalance to calculate total balance.
    const balance = this.sumConfirmedBalances(hasBalance, true)

    // Save the data to the wallet JSON file.
    walletInfo.balance = balance.totalConfirmed + balance.totalUnconfirmed
    walletInfo.balanceConfirmed = balance.totalConfirmed
    walletInfo.balanceUnconfirmed = balance.totalUnconfirmed
    walletInfo.hasBalance = hasBalance
    await appUtils.saveWallet(filename, walletInfo)

    return walletInfo
  }

  // Retrieves data for every address generated by the wallet.
  // Returns an array of address data for every address generated by the wallet.
  async getAllAddressData(walletInfo) {
    try {
      let addressData = [] // Accumulates address data.
      let currentIndex = 0 // tracks the current HD index.
      let batchHasBalance = true // Flag to signal when last address found.

      while (batchHasBalance) {
        // Get a 20-address batch of data.
        const thisDataBatch = await this.getAddressData(
          walletInfo,
          currentIndex,
          20
        )
        //console.log(`thisDataBatch: ${util.inspect(thisDataBatch)}`)

        // Increment the index by 20 (addresses).
        currentIndex += 20

        // Check if data has no balance. no balance == last address.
        batchHasBalance = this.detectBalance(thisDataBatch)
        //console.log(`batchHasBalance: ${batchHasBalance}`)

        // Add data to the array, unless this last batch has no balances.
        if (batchHasBalance) addressData = addressData.concat(thisDataBatch)

        //console.log(`addressData: ${util.inspect(addressData)}`)
      }

      return addressData
    } catch (err) {
      console.log(`Error in update-balances.js/getAllAddressData()`)
      throw err
    }
  }

  // Returns true if any of the address data has a balance.
  // dataBatch is expected to be an array of address data.
  detectBalance(dataBatch) {
    try {
      // Loop through the address data in the dataBatch array.
      for (let i = 0; i < dataBatch.length; i++) {
        const thisAddr = dataBatch[i]

        // Exit if a balance is detected in any of the addresses.
        if (thisAddr.totalReceivedSat > 0 || thisAddr.unconfirmedBalanceSat > 0)
          return true
      }

      // If the loop completes without finding a balance, return false.
      return false
    } catch (err) {
      console.log(`Error in update-balances.js/detectBalance()`)
      throw err
    }
  }

  // Retrieves details data (objects) on addresses in an HD wallet from rest.bitcoin.com
  // A max of 20 addresses can be retrieved at a time.
  // Addresses start at the index and the number of address data retrieved is
  // set by the limit (up to 20). Data is returned as an array of objects.
  async getAddressData(walletInfo, index, limit) {
    try {
      if (limit > 20) throw new Error(`limit must be 20 or less.`)

      console.log(
        `Getting address data at index ${index} up to index ${index + limit}`
      )

      // Get the list of addresses.
      const addresses = this.generateAddress(walletInfo, index, limit)
      //console.log(`addresses: ${util.inspect(addresses)}`)

      // get BCH balance and details for each address.
      const balances = await this.BITBOX.Address.details(addresses)

      return balances
    } catch (err) {
      console.log(`Error in update-balances.js/getAddressData()`)
      throw err
    }
  }

  // Generates an array of HD addresses.
  // Address are generated from index to limit.
  // e.g. generateAddress(walletInfo, 20, 10)
  // will generate a 20-element array of addresses from index 20 to 29
  generateAddress(walletInfo, index, limit) {
    // root seed buffer
    const rootSeed = this.BITBOX.Mnemonic.toSeed(walletInfo.mnemonic)

    // master HDNode
    if (walletInfo.network === "testnet")
      var masterHDNode = this.BITBOX.HDNode.fromSeed(rootSeed, "testnet")
    else var masterHDNode = this.BITBOX.HDNode.fromSeed(rootSeed)

    // HDNode of BIP44 account
    const account = this.BITBOX.HDNode.derivePath(masterHDNode, "m/44'/145'/0'")

    // Empty array for collecting generated addresses
    const bulkAddresses = []

    // Generate the addresses.
    for (let i = index; i < index + limit; i++) {
      // derive an external change address HDNode
      const change = this.BITBOX.HDNode.derivePath(account, `0/${i}`)

      // get the cash address
      const newAddress = this.BITBOX.HDNode.toCashAddress(change)
      //const legacy = this.BITBOX.HDNode.toLegacyAddress(change)

      //push address into array
      bulkAddresses.push(newAddress)
    }

    return bulkAddresses
  }

  // Generates the data that will be stored in the hasBalance array of the
  // wallet JSON file.
  generateHasBalance(addressData) {
    const hasBalance = []

    // Loop through each HD address index
    for (var i = 0; i < addressData.length; i++) {
      const thisAddr = addressData[i]

      // If the address has a balance, add it to the hasBalance array.
      if (thisAddr.balance > 0 || thisAddr.unconfirmedBalance > 0) {
        const thisObj = {
          index: i,
          balance: thisAddr.balance,
          balanceSat: thisAddr.balanceSat,
          unconfirmedBalance: thisAddr.unconfirmedBalance,
          unconfirmedBalanceSat: thisAddr.unconfirmedBalanceSat,
          cashAddress: thisAddr.cashAddress
        }

        hasBalance.push(thisObj)
      }
    }

    return hasBalance
  }

  // Sums the confirmed balances in the hasBalance array to create a single,
  // aggrigate balance
  sumConfirmedBalances(hasBalance, verbose) {
    let total = 0
    let totalConfirmed = 0
    let totalUnconfirmed = 0

    for (var i = 0; i < hasBalance.length; i++) {
      const thisHasBalance = hasBalance[i]

      total += thisHasBalance.balance + thisHasBalance.unconfirmedBalance
      totalConfirmed += thisHasBalance.balance
      totalUnconfirmed += thisHasBalance.unconfirmedBalance
    }

    const ONE_COIN = 100000000

    // Convert to satoshis
    const totalSatoshis = Math.floor(total * ONE_COIN)
    const totalConfirmedSatoshis = Math.floor(totalConfirmed * ONE_COIN)
    const totalUnconfirmedSatoshis = Math.floor(totalUnconfirmed * ONE_COIN)

    // Convert back to BCH
    total = totalSatoshis / ONE_COIN
    totalConfirmed = totalConfirmedSatoshis / ONE_COIN
    totalUnconfirmed = totalUnconfirmedSatoshis / ONE_COIN

    if (verbose) return { totalConfirmed, totalUnconfirmed }

    return total
  }
}

UpdateBalances.description = `Poll the network and update the balances of the wallet.`

UpdateBalances.flags = {
  name: flags.string({ char: "n", description: "Name of wallet" })
}

module.exports = UpdateBalances
